<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>8-信息检索的评价</title>
    <url>/8-%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E7%9A%84%E8%AF%84%E4%BB%B7/</url>
    <content><![CDATA[<blockquote>
<p>如何对一个信息检索系统进行评价</p>
</blockquote>
<span id="more"></span>
<h2 id="信息检索系统的评价"><a href="#信息检索系统的评价" class="headerlink" title="信息检索系统的评价"></a>信息检索系统的评价</h2><p>采用常规的方式来度量 ad hoc IR 系统的效果，需要一个测试集（test collection），由以下 3 个部分构成：</p>
<ol>
<li>一个文档集；</li>
<li>一组用于测试的信息需求集合，信息需求可以表示成查询；</li>
<li>一组相关性判定结果，对每个查询—文档对而言，通常会赋予一个二值判断结果——要么相关，要么不相关。</li>
</ol>
<p>由于在不同的文档集和信息需求上的结果差异较大，所以需要在相对较大的测试集合上对不同信息需求的结果求平均。经验上发现 <strong>50</strong> 条信息需求基本足够（同时 50 也是满足需要的最小值）。</p>
<p>需要注意的是，相关性判定是基于信息需求而不是基于查询来进行的，比如，有这样一个信息需求：在降低心脏病发作的风险方面，饮用红葡萄酒是否比饮用白葡萄酒更有效（原文是 whether drinking red wine is more effective at reducing your risk of heart attacks than drinking white wine）。该需求可能会表达成查询 wine AND red AND white AND heart AND attack AND effective。</p>
<p>要评价一个系统，需要对信息需求进行显式的表达，以便利用它对返回文档进行相关性判定。</p>
<p>为了避免过拟合，应给定一个或者多个开发测试集（development test collection），在这个开发测试集上调节参数直至最佳性能，然后测试者再将这些参数应用到最后的测试集上，最后在该测试集上得到的结果性能才是真实性能的无偏估计结果。</p>
<h2 id="标准测试集"><a href="#标准测试集" class="headerlink" title="标准测试集"></a>标准测试集</h2><p>下面列出了一些常用的标准测试集及相关的评测会议，这里我们主要关注用于 ad hoc 信息检索系统评价的测试集，但是也提到了一些用于文本分类任务的测试集。</p>
<ul>
<li><strong>CRANFIELD Cranfield 测试集</strong>，它是对信息检索系统的效果进行精确定量评价的首个测试集，但是对现在来说它的规模上已经非常小，只能用于最基本的试验性工作。该测试集于 20世纪 50 年代末期在英国收集而得，总共包含 1 398 篇空气动力学期刊的文章摘要、225 个查询以及所有的（查询,文档）对的相关性判定结果。</li>
<li><strong>TREC</strong> TREC（Text Retrieval Conference，文本检索会议），是从 1992 年开始由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所）组织的大型 IR 系统的年度评测会议。这个框架下定义了很多任务，每个任务都有自己的测试集。但是，其中最著名的测试集还是用于 1992 到 1999 年间的最早 8 次 TREC Ad Hoc 任务的测试集。这些测试集总共由 6 张 CD 组成，包括 189 万篇文档（主要是新闻类文章，也包括其他类型的文章）、450 个信息需求及相关性判定，在 TREC 中每个信息需求也称为主题（topic），并用详细的文字进行描述。多个不同的测试集定义在上述数据集的子集上。由于这个子测试集的规模最大，主题也比较一致，该子测试集可能是未来可用的最佳子集。由于 TREC 中的文档集都相当大，所以评测中并没有完整的相关性判定。实际上，给定信息需求，NIST 评估者仅仅针对 TREC 所提交的每个系统的前 k 篇返回文档做相关性判定。</li>
<li><strong>GOV2</strong> 近年来，NIST 在较大规模的文档集上进行了评价测试，这其中包括 2 500 万网页组成的 GOV2 文档。从 TREC 一开始，NIST 就提供了比已有供研究者使用的数据大几个数量级的测试集，GOV2 是目前易获得的、用于研究目的的最大规模的 Web 文档集。然而，GOV2 在规模上仍然比现有的大型搜索引擎厂商索引的网页至少要小 2 个数量级。</li>
<li><strong>NTCIR</strong> 日本国立情报研究所的信息检索测试集（NII Test Collections for IR Systems）的简称。NTCIR 项目构造了多个和 TREC 文档集规模相当的文档集，其中大部分文档都集中关注东亚语言和跨语言检索任务。这里提到的跨语言检索指的是这样的一种检索任务：查询是一种语言，而待检索文档由另外一种或者多种语言所构成。详细内容请参考 [<a href="http://research.nii.ac.jp/ntcir/data/data-en.html]%E3%80%82">http://research.nii.ac.jp/ntcir/data/data-en.html]。</a></li>
<li><strong>CLEF</strong> 跨语言评价论坛（Cross Language Evaluation Forum）的简称。该评价会议系列主要关注欧洲语言及它们之间的跨语言检索任务。详情请参考 [<a href="http://www.clef-campaign.org/]%E3%80%82">www.clef-campaign.org/]。</a></li>
<li><strong>Reuters语料</strong> 包括 Reuters-21578 和 Reuters-RCV1 语料。对于文本分类任务，最常用的测试集一直是 Reuters-21578 语料，它由 21 578 篇新闻报道组成（参见第 13 章）。近年来，Reuters发布了一个更大规模的语料库 RCV1（Reuters Corpus Volume1），它包括 806 791 篇文档（参见第 4 章）。RCV1 的规模和丰富的标注信息为未来的研究提供了更好的基础。</li>
<li><strong>20 Newsgroups</strong> 这是另一个广泛使用的文本分类语料，来自 Ken Lang 所收集的新闻组语料。 它从 20 个 Usenet 新闻组（新闻组的名字即类别的名称）的每个组中取 1 000 篇文章构成。去掉重复文章以后，通常所用的语料中包含 18 941 篇文章。</li>
</ul>
<h2 id="无序检索结果集合的评价"><a href="#无序检索结果集合的评价" class="headerlink" title="无序检索结果集合的评价"></a>无序检索结果集合的评价</h2><p>信息检索中最常用的两个基本指标是正确率和召回率。它们最早定义于一种非常简单的情况下：对于给定的查询，IR 系统返回一系列文档集合，其中的文档之间并不考虑先后顺序。后面将介绍如何将这些概念扩展到有序的检索中去。</p>
<p>正确率（Precision，简记为 P）是返回的结果中相关文档所占的比例，定义为：<br>Precision &#x3D; 返回结果中相关文档的数目&#x2F;返回结果的数目 &#x3D; P(relevant | retrieved)</p>
<p>召回率（Recall，简记为 R）是返回的相关文档占所有相关文档的比例，定义为：<br>Recall &#x3D; 返回结果中相关文档的数目&#x2F;所有相关文档的数目 &#x3D; P(retrieved | relevant)</p>
<p>为了更好地理解上述概念，可以对照如下列联表（contingency table）：</p>
<img src="/8-%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E7%9A%84%E8%AF%84%E4%BB%B7/1-%E5%85%B3%E8%81%94%E8%A1%A8.png" class="" title="关联表">
<p>于是有：</p>
<ul>
<li>P &#x3D; tp&#x2F;(tp + fp)</li>
<li>R &#x3D; tp&#x2F;(tp + fn)</li>
</ul>
<p>一个很容易想到的指标是精确率（accuracy），即文档集中所有判断正确的文档所占的比例。计算公式为：(tp + tn)&#x2F;(tp + fp + fn + tn)。精确率指标在很多机器学习问题中的使用非常普遍，是一个非常适合这类问题的效果度量指标。但是在信息检索中，超过 99.9%的文档都是不相关文档。只需要简单地将所有的文档都判成不相关文档，就会获得非常高的精确率值，这显然是不合适的。</p>
<p>普通用户非常关注高正确率，希望第一页的所有的结果都是相关的；相反地，一些专业的搜索人士（如律师助手、情报分析师等）却往往重视高召回率，有时甚至宁愿忍受极低的正确率也要获得高的召回率。对本机硬盘进行搜索的个人用户也常常关注召回率。<br>一个极端的情况是，对于某查询如果返回所有文档，显然此时的召回率为 1，但是此时的正确率往往却很低。一方面，相对于返回文档的数目而言，召回率是一个单调非减函数；另一方面，在一个好的系统中，正确率往往会随着返回文档数目的增加而降低。通常来说，我们希望在容许较小的错误率（此时会达到较高的正确率）的同时达到一定的召回率。</p>
<p>一个融合了正确率和召回率的指标是 F 值（F measure），它是正确率和召回率的调和平均值，定义如下：</p>
<img src="/8-%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E7%9A%84%E8%AF%84%E4%BB%B7/2-F%E5%80%BC.png" class="" title="F值">
<p>α ∈ [0, 1]，因此 β² ∈ [0, ∞]，默认情况下，平衡 F 值（balanced F measure）中正确率和召回率的权重相等，即 α &#x3D; 1&#x2F;2 或 β &#x3D; 1。尽管是从 α 的角度来体现出 F 是正确率和召回率的调和平均值，但上述等权重情况下我们可以用 β 的取值来记 F 值，此时记为 F1，它是Fβ&#x3D;1的省略形式。当 β &#x3D; 1 时，F 的计算公式可以简化为：Fβ&#x3D;1 &#x3D; 2PR&#x2F;(P+R)，β &lt; 1 表示强调正确率，而 β &gt; 1 表示强调召回率</p>
<h2 id="有序检索结果集合的评价"><a href="#有序检索结果集合的评价" class="headerlink" title="有序检索结果集合的评价"></a>有序检索结果集合的评价</h2><p>8.5 节讨论了如何开发可靠的、内容充实的测试集。<br>随后，在 8.6 节我们回过头来介绍用户效用（User utility）的概念，并介绍如何通过文档的<br>相关性来对它进行近似估计。最关键的效用指标是用户满意度。响应速度和索引大小是用户满<br>意度的影响因子。“ 结果的相关性是最重要的因子” 这个假设看上去很合理，因为响应速度很快<br>但不相关的回答结果并不会令用户满意。然而，用户的满意度和系统设计者所理解的结果质量<br>概念之间并不完全一致。比如，用户的满意度通常都很大程度上依赖于用户界面的设计，包括<br>布局、架构清晰度及用户界面的响应等等因素，而这些因素与系统返回结果的质量无关。最后<br>我们会谈及其他质量检索结果度量的技术（见 8.7 节），特别是高质量的文档摘要片段的生成<br>方法，它对用户效用的影响很大，但是它并没有包括在基本的相关度排序模式中。</p>
]]></content>
      <categories>
        <category>信息检索</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<blockquote>
<p>尝试整理下计网的知识</p>
</blockquote>
<span id="more"></span>

<h2 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h2><p>RFC文档中的定义：</p>
<img src="/HTTP%E5%8D%8F%E8%AE%AE/2.png" class="" title="HTTP定义">
<ol>
<li>首先是a stateless，一个无状态的协议。即连续的两个请求中，后一个请求不能依赖前一个请求中相应的字段或者head、头部等。</li>
<li>第二是一个request&#x2F;response方式，基于一个连接，首先由客户端来发起请求，然后服务器在这个连接上发起一个response响应</li>
<li>第三个关键词是extensible semantics，语义可扩展。比如说有些服务器还在使用很老的ICP1.0的版本，不支持HP1.1协议。但是浏览器是支持ICP1.1协议的，那么浏览器和服务器仍然可以正常的通讯。</li>
<li>第四个关键词就是self-descriptive。即传递的消息是一个自描述的消息。从一个请求中就知道这段消息到底是一段视频一张图片还是一段音频，而不需要依赖于其他的请求。</li>
<li>第五个关键词就是hypertext information，这是一个超文本系统，所传输的不只有文档，还有图片、音频视频等内容。</li>
</ol>
<h2 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h2><img src="/HTTP%E5%8D%8F%E8%AE%AE/1_HTTP%E8%AF%B7%E6%B1%82.png" class="" title="HTTP请求">
<p>首先有一个服务器，监听打开了80或者443的web端口。浏览器从UIL中首先解析出来域名，然后根据域名去查询DNS，获取到域名对应的IP地址。接着浏览器用这个IP地址与服务器建立起了TCP连接。如果使用的是HTPS，那么还要完成TLS和SSL的握手。在建立好连接以后，需要构造HTTP请求。在构造请求过程中，需要填充相应的HTTP头部，包括上下文所需要的信息。最后通过这个链接发起HTTP请求。</p>
<p>当服务器收到这个HTTP请求以后，完成资源的表述，把HTML页面或者javascript页面等作为包体返回给浏览器。浏览器在渲染引擎中就会解析这个响应。根据这个响应中具备的其他超链接、图片等资源，在再次发起新的HTTP请求，这就是最基本的浏览器发起HTTP请求的流程。</p>
<h2 id="基于ABNF的HTTP协议消息"><a href="#基于ABNF的HTTP协议消息" class="headerlink" title="基于ABNF的HTTP协议消息"></a>基于ABNF的HTTP协议消息</h2><p>一个标准定义语法，用到了再学</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基础语法</title>
    <url>/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>Markdown用法并不唯一，笔者所列仅为个人习惯</p>
</blockquote>
<span id="more"></span>

<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="# 一级标题"></a># 一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="## 二级标题"></a>## 二级标题</h2><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="###### 六级标题"></a>###### 六级标题</h6><p>可选用法</p>
<h1 id="一级标题（下加若干-）"><a href="#一级标题（下加若干-）" class="headerlink" title="一级标题（下加若干&#x3D;）"></a>一级标题（下加若干&#x3D;）</h1><h2 id="二级标题（下加若干-）"><a href="#二级标题（下加若干-）" class="headerlink" title="二级标题（下加若干-）"></a>二级标题（下加若干-）</h2><p>*** 分割线</p>
<hr>
<p>换行<br>等于加空格</p>
<p>分段</p>
<p>要空一行</p>
<hr>
<p> <strong>加粗</strong> ** **，快捷键ctrl+B</p>
<p><em>斜体</em> * *，快捷键ctrl+I</p>
<p><em><strong>又粗又斜</strong></em> *** ***</p>
<hr>
<blockquote>
<p>引用 &gt;</p>
<blockquote>
<p>嵌套引用&gt;&gt;</p>
</blockquote>
<h2 id="可以嵌套标题"><a href="#可以嵌套标题" class="headerlink" title="可以嵌套标题"></a>可以嵌套标题</h2><p><strong>粗体</strong></p>
<p><em>斜体</em></p>
<hr>
<p>分割线</p>
<p>并不是所有元素都能嵌套（反例呢，快来救一下（急））</p>
</blockquote>
<hr>
<ul>
<li>无序列表 -<ul>
<li>tab键缩进以嵌套<ul>
<li>多层嵌套</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>有序列表 1.<ol>
<li>这个好像不好用<ol>
<li>序号不能变</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C语言代码块</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">好酷!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>ctrl+&#x2F; 注释</p>
<!-- 这是注释,看不到哎,好酷
这里写"More"会在网页中隐藏后面内容,跳转到详情页才能看 -->

<p>超链接用法:<br>[超链接显示名] (超链接地址 “超链接title”)<br><a href="%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" title="超链接title">超链接显示名</a></p>
<p><a href="mailto:&#x31;&#x32;&#x33;&#64;&#113;&#113;&#x2e;&#99;&#111;&#x6d;">&#x31;&#x32;&#x33;&#64;&#113;&#113;&#x2e;&#99;&#111;&#x6d;</a> &lt;邮箱&gt;</p>
<p><a href="https://123.com/">https://123.com</a> &lt;网址&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  A(把大象放进去) --&gt; B&#123;&quot;冰箱小不小？&quot;&#125;</span><br><span class="line">  B --&gt; |不小| C[把冰箱门关上]</span><br><span class="line">  B --&gt;   |小| D[换个大点的冰箱]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux提权</title>
    <url>/Linux%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<h1 id="Part1-sudo介绍"><a href="#Part1-sudo介绍" class="headerlink" title="Part1 sudo介绍"></a>Part1 sudo介绍</h1><h2 id="什么是sudo"><a href="#什么是sudo" class="headerlink" title="什么是sudo"></a>什么是sudo</h2><p>简单的说，sudo 是一种&#x3D;&#x3D;权限管理机制&#x3D;&#x3D;，管理员可以授权于一些普通用户去执行一些 root 执行的操作，提示输入密码时该密码为当前用户的密码，而不需要知道 root 的密码。不过有时间限制，Ubuntu默认为一次时长15分钟</p>
<span id="more"></span>

<p>严谨些说，sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 &#x3D;&#x3D;&#x2F;etc&#x2F;sudoers&#x3D;&#x3D; 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入&#x3D;&#x3D;自己账号的密码。&#x3D;&#x3D;如果验证失败，sudo 命令将会退出。</p>
<p>默认的etc&#x2F;sudoers配置文件：</p>
<p><img src="/%5CLinux%E6%8F%90%E6%9D%83%5C1.png" alt="图片"></p>
<br/>

<h1 id="Part2-CVE-2021-3156漏洞"><a href="#Part2-CVE-2021-3156漏洞" class="headerlink" title="Part2 CVE-2021-3156漏洞"></a>Part2 CVE-2021-3156漏洞</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>2021年1月26日，Linux安全工具&#x3D;&#x3D;sudo&#x3D;&#x3D;被发现严重的基于&#x3D;&#x3D;堆缓冲区溢出&#x3D;&#x3D;漏洞。利用这一漏洞，攻击者无需知道用户密码，一样可以获得root权限，并且是在默认配置下。此漏洞已分配为CVE-2021-3156，危险等级评分为7分。</p>
<h2 id="2-原理介绍"><a href="#2-原理介绍" class="headerlink" title="2. 原理介绍"></a>2. 原理介绍</h2><p>漏洞发生的原因在于sudo错误地转义了参数中的反斜杠。</p>
<p>sudo命令允许用户以超级用户或&#x2F;etc&#x2F;sudoers文件中指定的其他用户的身份运行指定命令cmd。设置真实和有效用户ID与用户组ID，以匹配&#x2F;etc&#x2F;passwd文件中指定的目标用户和&#x2F;etc&#x2F;group文件中指定的用户组（除非指定了“-P”选项）。如果调用者是超级用户，或目标用户与调用者是同一用户，则无须提供密码。否则，sudo通常要求用户提供密码进行认证。注意，按照默认的配置，这里所谓的密码认证指的是用户的密码，不是超级用户的密码。</p>
<p>一旦获得认证，立即更新&#x2F;var&#x2F;run&#x2F;sudo目录中的用户时间记录。在之后的短时间内（5分钟，除非sudoers文件中另有设定），用户可以随时运行sudo命令而不必提供密码。</p>
<p>sudo与sudoedit是一个程序两个名字。运行sudoedit命令，相当于运行“sudo -e”命令。sudoedit命令主要用于编辑&#x2F;etc&#x2F;sudoers文件，参见“-e”选项的说明。</p>
<p>当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或-i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。因此只要存在sudoers文件（通常是&#x2F;etc&#x2F;sudoers），攻击者就可以使用本地普通用户利用sudo获得系统root权限。</p>
<h2 id="3-影响版本"><a href="#3-影响版本" class="headerlink" title="3. 影响版本"></a>3. 影响版本</h2><p>受影响版本<br>Sudo 1.8.2 – 1.8.31p2<br>Sudo 1.9.0 – 1.9.5p1</p>
<p>不受影响版本<br>sudo &#x3D;&gt;1.9.5p2</p>
<h2 id="4-漏洞复现"><a href="#4-漏洞复现" class="headerlink" title="4. 漏洞复现"></a>4. 漏洞复现</h2><br/>

<h1 id="Part3-CVE-2023-22809漏洞"><a href="#Part3-CVE-2023-22809漏洞" class="headerlink" title="Part3 CVE-2023-22809漏洞"></a>Part3 CVE-2023-22809漏洞</h1><h2 id="1-漏洞简介-1"><a href="#1-漏洞简介-1" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>在Sudo 版本 1.9.12p1中使用sudoedit时，sudoers的保护机制可能被绕过，从而导致通过编辑未经授权的文件实现权限升级，Sudo中的sudoedit对处理用户提供的环境变量（如SUDO_EDITOR、VISUAL和EDITOR）中传递的额外参数存在缺陷。当用户指定的编辑器包含绕过sudoers策略的“–”参数时，拥有sudoedit访问权限的本地攻击者可通过将任意条目附加到要处理的文件列表中，最终在目标系统上实现权限提升（由普通用户到超级用户，即”root”）</p>
<h2 id="2-原理介绍-1"><a href="#2-原理介绍-1" class="headerlink" title="2. 原理介绍"></a>2. 原理介绍</h2><br/>

<h2 id="3-影响版本-1"><a href="#3-影响版本-1" class="headerlink" title="3. 影响版本"></a>3. 影响版本</h2><p>sudo 1.8.0-sudo 1.9.12p1</p>
<h2 id="4-漏洞复现-1"><a href="#4-漏洞复现-1" class="headerlink" title="4. 漏洞复现"></a>4. 漏洞复现</h2><ol>
<li>查看当前sudo版本</li>
</ol>
<p><img src="/%5CLinux%E6%8F%90%E6%9D%83%5C2.png"></p>
<p>如上，为受影响版本，若不是，则在<a href="https://">https://www.sudo.ws/dist/</a>下载相应版本后解压、配置、编译并安装</p>
<br/>

<p><img src="/%5CLinux%E6%8F%90%E6%9D%83%5C3.png" alt="图片"></p>
<p><img src="/%5CLinux%E6%8F%90%E6%9D%83%5C4.png" alt="图片"></p>
<br/>

<h2 id="5-缓解措施"><a href="#5-缓解措施" class="headerlink" title="5. 缓解措施"></a>5. 缓解措施</h2><p>1、为防止 sudoedit 使用用户指定的编辑器，可向 sudoers 文件中添加以下内容： Defaults!sudoedit env_delete+&#x3D;”SUDO_EDITOR VISUAL EDITOR”<br>2、使用“Cmnd_Alias”限制编辑器编辑指定文件时，如： Cmnd_Alias EDIT_MOTD &#x3D; sudoedit &#x2F;etc&#x2F;motd Defaults!EDIT_MOTD env_delete+&#x3D;”SUDO_EDITOR VISUAL EDITOR” user ALL &#x3D; EDIT_MOTD</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><p><a href="https://">https://www.cnblogs.com/20181309lzy/p/14710439.html</a></p>
</li>
<li><p><a href="https://">https://wker.com/linux-command/sudo-sudoedit.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《战争史》初读</title>
    <url>/%E3%80%8A%E6%88%98%E4%BA%89%E5%8F%B2%E3%80%8B%E5%88%9D%E8%AF%BB/</url>
    <content><![CDATA[<hr>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><h3 id="书名：战争史"><a href="#书名：战争史" class="headerlink" title="书名：战争史"></a>书名：战争史</h3><h3 id="作者：John-Keegan（英）"><a href="#作者：John-Keegan（英）" class="headerlink" title="作者：John Keegan（英）"></a>作者：John Keegan（英）</h3><h3 id="译者：林华"><a href="#译者：林华" class="headerlink" title="译者：林华"></a>译者：林华</h3><hr>
<span id="more"></span>

<p>以下为初读摘抄</p>
<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>&emsp; 战争无疑与经济、外交和政治相关。但相关并不等于不同，甚至不等于相似。战争与外交和政治完全不同，因为真正打仗的人在价值观和技能方面与外交家和政治家迥然相异。军人的价值观和技能属于另一个世界，那是一个非常古老的世界，与日常的世界并存但不相属。随着时间的流逝，两个世界都在变化，武士世界按照平民世界的变化调整自己。然而，它总是和平民世界保持一定的距离</p>
]]></content>
      <categories>
        <category>战争史</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>cs155-project3</title>
    <url>/cs155-project3/</url>
    <content><![CDATA[<blockquote>
<p>斯坦福大学cs155课程project3，详情见<a href="https://cs155.stanford.edu/hw_and_proj/proj3/proj3.pdf">官网文档</a></p>
</blockquote>
<span id="more"></span>

<h2 id="Part-1-Nmap-Port-Scanning"><a href="#Part-1-Nmap-Port-Scanning" class="headerlink" title="Part 1 Nmap Port Scanning"></a>Part 1 Nmap Port Scanning</h2><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h3><ol>
<li>Only scan scanme.nmap.org. Do not scan any other servers. You should only scan a server if you have explicit permission from the server operator to do so.</li>
<li>Record the traffic with Wireshark (see part 2)</li>
<li>Use a TCP SYN scan. (Hint: Read the nmap man pages to find the appropriate flag to use.)</li>
<li>Enable OS detection, version detection, script scanning, and traceroute. (Hint: This is a single flag.)</li>
<li>Do a quick scan (-T4).</li>
<li>Scan all ports.</li>
</ol>
<p>概括来说，要求如下：</p>
<ul>
<li>只扫描<code>scanme.nmap.org</code></li>
<li>用Wireshark记录流量（Part2内容）</li>
<li>使用TCP SYN扫描</li>
<li>启动操作系统检测、版本检测、脚本扫描和路由跟踪</li>
<li>快速扫描所有端口</li>
</ul>
<p>综上，扫描命令如下：<br><code>sudo nmap -sS -A -T4 -p- scanme.nmap.org </code></p>
<ul>
<li>-sS: 表示进行TCP SYN扫描，这是一种半开放扫描，不会完成TCP三次握手，因此速度较快且不易被记录。</li>
<li>-A: 启动操作系统检测（OS detection）、版本检测（version detection）、脚本扫描（script scanning）和路由跟踪（traceroute）。</li>
<li>-T4: 设置扫描速度为“快速”（但不是最快）。Nmap支持从T0到T5的速度模板，T4是较快的选项，适合快速扫描，而不至于像T5那样可能因为太快而丢失一些结果。</li>
<li>-p-: 表示扫描所有端口（1-65535）。</li>
</ul>
<img src="/cs155-project3/1-nmap.png" class="" title="nmap">

<h3 id="提交内容："><a href="#提交内容：" class="headerlink" title="提交内容："></a>提交内容：</h3><ol>
<li>What is the full command you used to run the port scan (including arguments)?</li>
<li>What is the IP address of scanme.nmap.org?</li>
<li>What ports are open on the target server? What applications are running on those ports?<br>(For this part, you only need to report the service name printed by nmap.)</li>
<li>The target machine is also running a webserver. What webserver software and version is<br>being used? What ports does it run on?</li>
</ol>
<h2 id="Part-2-Wireshark-Packet-Sniffing"><a href="#Part-2-Wireshark-Packet-Sniffing" class="headerlink" title="Part 2 Wireshark Packet Sniffing"></a>Part 2 Wireshark Packet Sniffing</h2><h3 id="提交内容"><a href="#提交内容" class="headerlink" title="提交内容"></a>提交内容</h3><ol>
<li>What does it mean for a port on scanme.nmap.org to be “closed?” More specifically, what is<br>the TCP packet type, if any, the server gives in response to a SYN packet sent to port that<br>is “closed?”</li>
<li>What does it mean for a port on scanme.nmap.org to be “filtered?” More specifically, what<br>is the TCP packet type, if any, the server gives in response to a SYN packet sent to port that<br>is “filtered?”</li>
<li>In addition to performing an HTTP GET request to the webserver, what other http request<br>types does nmap send?</li>
<li>What TCP parameters does nmap alter to fingerprint the host’s operating system?</li>
</ol>
<p>Once again, please answer all questions briefly; no response should take more than two or three<br>sentences.</p>
<h2 id="Part-3-Programmatic-Packet-Processing"><a href="#Part-3-Programmatic-Packet-Processing" class="headerlink" title="Part 3  Programmatic Packet Processing"></a>Part 3  Programmatic Packet Processing</h2><h3 id="实验要求：-1"><a href="#实验要求：-1" class="headerlink" title="实验要求："></a>实验要求：</h3><p>Your task is to develop a Go program that analyzes a PCAP file in order to detect possible SYN scans and ARP spoofing attacks. To do this, you will use gopacket, a library for packet<br>manipulation and dissection, which you should have installed during setup earlier. You can find more information about gopacket at <a href="https://godoc.org/github.com/google/gopacket">https://godoc.org/github.com/google/gopacket</a>. In<br>particular, you should examine the “layers” Go package to parse different networking layers: <a href="https://github.com/google/gopacket/tree/v1.1.19/layers">https://github.com/google/gopacket/tree/v1.1.19/layers</a>.<br>Your program will take the path of the PCAP file to be analyzed as a command-line argument:<br><code>$ go run detector.go sample.pcap</code><br>The printed output should begin with the line Unauthorized SYN scanners:, followed by the set of IP addresses (one per line) that sent more than 3 times as many SYN packets as the number of SYN+ACK packets they received and also sent more than 5 SYN packets in total. In calculating this, your program should silently ignore packets that are malformed or that are not using Ethernet, IP, and TCP. The line immediately following these IP addresses should print the line Unauthorized ARP spoofers:, followed by the set of MAC addresses (one per line) that send more than 5 unso-licited ARP replies. Unsolicited ARP replies are those which contain a source IP and destination MAC address combination that does not correspond to a previous request (in other words, each request should correspond to at most one reply, and any extra replies are unsolicited).</p>
<h2 id="Part-4-Monster-in-the-Middle-Attack"><a href="#Part-4-Monster-in-the-Middle-Attack" class="headerlink" title="Part 4  Monster-in-the-Middle Attack"></a>Part 4  Monster-in-the-Middle Attack</h2>]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>cs155</tag>
        <tag>计算机安全</tag>
      </tags>
  </entry>
  <entry>
    <title>对抗机器学习(AML)</title>
    <url>/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/</url>
    <content><![CDATA[<p><strong>机器学习自身安全吗？</strong></p>
<hr>
<blockquote>
<p>本文为WHU_NCC内容安全课堂笔记（记了学完就忘，不记根本不学😭）内容碎片化且片面，仅供娱乐，别学习了</p>
<p>第七讲——对抗机器学习（这是第一篇，前面的大概率不会补了）</p>
</blockquote>
<span id="more"></span>
<hr>
<h2 id="引入：ML-AML"><a href="#引入：ML-AML" class="headerlink" title="引入：ML &amp; AML"></a>引入：ML &amp; AML</h2><p>什么是机器学习，放张图不细讲惹（因为自己也不会）</p>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/1_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.png" class="" title="机器学习">

<p>那什么是对抗机器学习呢？</p>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/2_%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.png" class="" title="对抗机器学习">
<p>如上图，输入的图片是经过处理后的攻击图片，人眼很难分辨出与原图的差距，模型却把它们识别成了完全不同的东西（分别是鹈鹕、快艇和牛仔裤），听起来并没有多可怕，但试想一下，哪天你坐车里吃着火锅唱着歌，你的车载AI把前面的STOP路牌看成了限速120，想想都刺激（bushi）</p>
<p>总之，这是一个亟需重视的领域，如果说在GPT等大模型出来之前，AML只是垃圾邮件对抗之类的小打小闹，那现在随着人工智能的井喷式发展，它可能就是悬在人类头上的“达摩克里斯之剑”了（突然严肃）</p>
<hr>
<h2 id="AML基本介绍"><a href="#AML基本介绍" class="headerlink" title="AML基本介绍"></a>AML基本介绍</h2><p>全称: Adversarial Machine Learning</p>
<p>是机器学习和计算机安全的一个交叉领域，分为攻（欺骗检测器）防（确保准确）</p>
<h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><p>先放图：</p>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/3_%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%B6%E9%97%B4%E7%BA%BF.png" class="" title="对抗机器学习时间线">
<p>开创于2004年. Dalvi等针对垃圾邮件过滤问题提出对抗分类 (Adversarial classification)概念，其核心思想是分析机器学习算法在遭受特定攻击时的安全性。（比我想得要早）</p>
<p>以下为一个简单演示：</p>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/4_%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB.png" class="" title="垃圾邮件分类">
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/5_%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E6%94%BB%E5%87%BB.png" class="" title="垃圾邮件攻击">
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/6_%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E9%98%B2%E5%BE%A1.png" class="" title="垃圾邮件防御">
<ul>
<li>2005 年, Lowd 等提出对抗学习 (Adversarial learning) 概念</li>
<li>2006年，Barreno 等提出机器学习系统的攻击分类和敌手建模 (Adversary Model）</li>
<li>2010 年，Dasgupta 等将对抗机器学习形式化为学习器 (Learner) 与敌手 (Adversary) 围绕不同目标进行的博弈。其中, 学习器的目标是<strong>对数据进行正确预测或分类</strong>, 敌手的目标则是<strong>诱使学习器对相关的数据做出错误的预测</strong></li>
</ul>
<hr>
<h3 id="AML敌手模型"><a href="#AML敌手模型" class="headerlink" title="AML敌手模型"></a>AML敌手模型</h3><p>听不懂思密达，觉得很高级就copy了下来</p>
<h4 id="敌手目标-Adversary-goal"><a href="#敌手目标-Adversary-goal" class="headerlink" title="敌手目标 (Adversary goal)"></a>敌手目标 (Adversary goal)</h4><ul>
<li>完整性违规 (Integrity violation)<ul>
<li>不影响合法用户对系统功能正常使用的同时, 达到规避检测的目的</li>
</ul>
</li>
<li>可用性违规 (Availability violation) <ul>
<li>危害合法用户对系统功能正常使用, 甚至造成系统对用户的拒绝服务</li>
</ul>
</li>
</ul>
<h4 id="敌手知识-Adversary-knowledge"><a href="#敌手知识-Adversary-knowledge" class="headerlink" title="敌手知识 (Adversary knowledge)"></a>敌手知识 (Adversary knowledge)</h4><p>攻击者掌握的机器学习模型的相关知识，可包括:</p>
<ol>
<li>训练数据 D；</li>
<li>特征集X⊆Rd; </li>
<li>模型结构和参数 f : X→ R</li>
</ol>
<ul>
<li>白盒攻击：假设攻击者可以完全获取目标模型的结构和参数等信息 </li>
<li>黑盒攻击：假设攻击者只能获取模型的最终决策结果</li>
</ul>
<h4 id="敌手能力-Adversary-capability"><a href="#敌手能力-Adversary-capability" class="headerlink" title="敌手能力 (Adversary capability)"></a>敌手能力 (Adversary capability)</h4><p>指攻击者对机器学习模型的操作权限</p>
<ul>
<li>训练阶段：投毒攻击, 后门攻击</li>
<li>测试阶段：规避攻击, 隐私窃取</li>
</ul>
<p>敌手能力可以形式化为优化问题中的约束条件 </p>
<hr>
<h2 id="对抗攻击技术"><a href="#对抗攻击技术" class="headerlink" title="对抗攻击技术"></a>对抗攻击技术</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>大概分为两类</p>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/7_%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%88%86%E7%B1%BB.png" class="" title="对抗攻击分类">
<p>数据投毒(Data poisoning )：归因性攻击（Causative attack）</p>
<ul>
<li>训练阶段</li>
<li>攻击者通过干扰训练数据集来欺骗模型<ul>
<li>训练集中加入恶意样本</li>
<li>修改训练集的数据实例</li>
<li>改变训练数据标签</li>
</ul>
</li>
<li>攻击者试图干扰和破坏ML模型和算法）</li>
</ul>
<p>规避攻击(Evasion attack)：试探性攻击 (Exploratory attack)</p>
<ul>
<li>测试阶段</li>
<li>攻击者无需修改ML模型，仅让模型出错，产生攻击者需要的输出</li>
<li><strong>Evasion attack</strong> 是最常用的攻击手段</li>
</ul>
<p>其他分类：黑盒&#x2F;白盒攻击、有目标&#x2F;无目标攻击，此处不细讲</p>
<h3 id="规避攻击"><a href="#规避攻击" class="headerlink" title="规避攻击"></a>规避攻击</h3><p>照例，先放张图</p>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/8_%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB1.png" class="" title="规避攻击">

<h4 id="1-基于模仿"><a href="#1-基于模仿" class="headerlink" title="1. 基于模仿"></a>1. 基于模仿</h4><p>采用启发式算法, 直接修改文件结构或内容 </p>
<p>向恶意样本添加良性样本的特征, 或向良性样本中添加恶意样本的特征, 使得修改后的样本在实现恶意功能的同时, 将结构差异降至最低, 从而规避分类器的检测，如<strong>垃圾邮件规避攻击</strong>（好词插入，坏词混淆）</p>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/9_%E5%9F%BA%E4%BA%8E%E6%A8%A1%E4%BB%BF%E7%9A%84%E8%A7%84%E9%81%BF%E6%94%BB%E5%87%BB.png" class="" title="基于模仿的规避攻击">

<h4 id="2-基于梯度"><a href="#2-基于梯度" class="headerlink" title="2. 基于梯度"></a>2. 基于梯度</h4><p>利用梯度下降求解优化问题, 对输入样本执行细粒度的修改, 以最小化 (最大化) 样本被归类为恶意 (良性) 的概率 </p>
<p>应用梯度下降函数, 在损失函数最可能增加的方向上扰动测试样本, 使恶意样本向着合法样本的区域移动, 从而被分类器错分为正常样本。</p>
<ul>
<li>L-BFGS：限制内存方法 (Limited-memory broyden fletcher goldfarb shanno)</li>
<li>FGSM：快速梯度符号法 (Fast gradient sign method) </li>
<li>JSMA：基于雅可比矩阵的显著图攻击算法 (Jacobian-base saliency map attack) </li>
<li>C&amp;W 算法</li>
</ul>
<h4 id="3-基于迁移"><a href="#3-基于迁移" class="headerlink" title="3. 基于迁移"></a>3. 基于迁移</h4><p>利用了对抗样本的跨模型迁移性。可应用于无法获取模型梯度的各种攻击场景 </p>
<p>基于对抗样本的跨模型迁移性。攻击者通过构建代理模型 (Surrogate model) 的方式, 利用已知机器学习模型构造对抗样本, 然后攻击相关的未知模型</p>
<p>生成对抗网络 GAN（Generative adversarial networks ）<br>采用博弈论中的纳什均衡思想, 通过多回合的对抗训练, 使得生成器学到目标样本分布, 从而用于规避攻击</p>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/10_GAN.png" class="" title="GAN">

<hr>
<h3 id="投毒攻击"><a href="#投毒攻击" class="headerlink" title="投毒攻击"></a>投毒攻击</h3><p>对训练数据进行修改或者添加少量数据进行污染, 寻求全局或局部分布的扰动, 进而破坏模型可用性和完整性, 降低机器学习系统性能。</p>
<p>投毒攻击是对主流机器学习算法的一种重要威胁, 包括<strong>支持向量机、贝叶斯分类器、层次聚类以及 逻辑回归</strong>等常规算法都受到了投毒攻击的危害 </p>
<p>针对数据库发起投毒攻击, 可以实现 “立竿见影”的效果, 同时得到极为丰厚的回报, 使得投毒攻击发生更为频繁。</p>
<p>卡巴斯基实验室被指控向 VirusTotal 注入假阳性样本（将良性的、系统关键文件标记为恶意文件），当对手在新样本上训练病毒扫描器时, 这些扫描器会将合法的系统文件标记为恶意, 从而毒害竞争对手的杀毒产品</p>
<ul>
<li>可用性攻击：降低分类器分类精度并产生高误报率, 从而无法为正常用户提供服务, 甚至使系统拒绝服务</li>
<li>完整性攻击：使机器学习产生较高漏报率, 降低成功检测到恶意活动的几率</li>
</ul>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/11_%E6%B2%B9%E8%9B%99%E6%94%BB%E5%87%BB.png" class="" title="油蛙攻击">

<h2 id="常用规避攻击技术"><a href="#常用规避攻击技术" class="headerlink" title="常用规避攻击技术"></a>常用规避攻击技术</h2><h3 id="1-噪声攻击（Noise-attack）"><a href="#1-噪声攻击（Noise-attack）" class="headerlink" title="1.噪声攻击（Noise attack）"></a>1.噪声攻击（Noise attack）</h3><p>最简单的对抗攻击技术</p>
<p>Noise is a random arrangement of pixels containing no information（不包含任何信息的随机像素排列）</p>
<p>通过随机函数生成，是一种无目标的黑盒逃逸攻击</p>
<img src="/%E5%AF%B9%E6%8A%97%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AML/12-%E5%99%AA%E5%A3%B0%E6%94%BB%E5%87%BB.png" class="" title="噪声攻击">

<h3 id="2-语义攻击（Semantic-attack）"><a href="#2-语义攻击（Semantic-attack）" class="headerlink" title="2.语义攻击（Semantic attack）"></a>2.语义攻击（Semantic attack）</h3><h3 id="3-快速梯度符号攻击（FGSM，Fast-gradient-sign-method-attack）"><a href="#3-快速梯度符号攻击（FGSM，Fast-gradient-sign-method-attack）" class="headerlink" title="3.快速梯度符号攻击（FGSM，Fast gradient sign method attack）"></a>3.快速梯度符号攻击（FGSM，Fast gradient sign method attack）</h3><h3 id="4-基础迭代攻击（BIM，Basic-iterative-method-attack）"><a href="#4-基础迭代攻击（BIM，Basic-iterative-method-attack）" class="headerlink" title="4.基础迭代攻击（BIM，Basic iterative method attack）"></a>4.基础迭代攻击（BIM，Basic iterative method attack）</h3><h3 id="5-投影梯度下降攻击（PGD，Projected-gradient-descent-attack）"><a href="#5-投影梯度下降攻击（PGD，Projected-gradient-descent-attack）" class="headerlink" title="5.投影梯度下降攻击（PGD，Projected gradient descent attack）"></a>5.投影梯度下降攻击（PGD，Projected gradient descent attack）</h3><h3 id="6-深度欺骗攻击（DeepFool-attack-）"><a href="#6-深度欺骗攻击（DeepFool-attack-）" class="headerlink" title="6.深度欺骗攻击（DeepFool attack ）"></a>6.深度欺骗攻击（DeepFool attack ）</h3><h3 id="7-C-W攻击（CW-Carlini-Wagner-attack-）"><a href="#7-C-W攻击（CW-Carlini-Wagner-attack-）" class="headerlink" title="7.C&amp;W攻击（CW, Carlini-Wagner attack ）"></a>7.C&amp;W攻击（CW, Carlini-Wagner attack ）</h3><h2 id="对抗防御技术"><a href="#对抗防御技术" class="headerlink" title="对抗防御技术"></a>对抗防御技术</h2><h2 id="语音对抗攻击及防御技术"><a href="#语音对抗攻击及防御技术" class="headerlink" title="语音对抗攻击及防御技术"></a>语音对抗攻击及防御技术</h2><h3 id="语音对抗样本技术"><a href="#语音对抗样本技术" class="headerlink" title="语音对抗样本技术"></a>语音对抗样本技术</h3><h3 id="语音对抗防御技术"><a href="#语音对抗防御技术" class="headerlink" title="语音对抗防御技术"></a>语音对抗防御技术</h3>]]></content>
      <categories>
        <category>内容安全</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>由于对C语言的qsort函数有所遗忘，因此复习下排序算法</p>
<p>参考链接：<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a></p>
</blockquote>
<span id="more"></span>

<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。总结如下：</p>
<img src="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort1.png" class="" title="sort1">
<img src="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort2.png" class="" title="sort2">

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p>
<p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p>
<p><strong>算法步骤</strong>：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i, j, temp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                                temp = arr[j];</span><br><span class="line">                                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        bubble_sort(arr, len);</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧</p>
<p><strong>算法步骤</strong>：</p>
<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span> <span class="comment">//交換兩個變數</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">                <span class="type">int</span> min = i;</span><br><span class="line">                <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//走訪未排序的元素</span></span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//找到目前最小值</span></span><br><span class="line">                                min = j;    <span class="comment">//紀錄最小值</span></span><br><span class="line">                swap(&amp;arr[min], &amp;arr[i]);    <span class="comment">//做交換</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<p><strong>算法步骤</strong>:</p>
<ul>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ul>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j,key;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                key = arr[i];</span><br><span class="line">                j=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (arr[j]&gt;key)) &#123;</span><br><span class="line">                        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序，也称递减增量排序算法，是<strong>插入排序</strong>的一种更高效的改进版本。但希尔排序是<strong>非稳定排序</strong>算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p><strong>算法步骤</strong>:</p>
<ul>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shell_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> gap, i, j;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                        temp = arr[i];</span><br><span class="line">                        <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                                arr[j + gap] = arr[j];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序-不是很懂"><a href="#归并排序-不是很懂" class="headerlink" title="归并排序(不是很懂)"></a>归并排序(不是很懂)</h4><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<p><strong>算法步骤</strong>:</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
<p><strong>算法实现</strong>：</p>
<p>迭代版：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *a = arr;</span><br><span class="line">    <span class="type">int</span> *b = (<span class="type">int</span> *) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += seg * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class="number">2</span>, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归版</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> reg[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="type">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="type">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<p><strong>算法步骤</strong>:</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ul>
<p><strong>算法实现</strong>：</p>
<p>迭代版</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">&#125; Range;</span><br><span class="line"></span><br><span class="line">Range <span class="title function_">new_Range</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等于负值时引发段错误（Segment Fault）</span></span><br><span class="line">    <span class="comment">// r[]模拟列表,p为数量,r[p++]为push,r[--p]为pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>]; <span class="comment">// 选取中间点为基准点</span></span><br><span class="line">        <span class="type">int</span> left = range.start, right = range.end;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) ++left;   <span class="comment">// 检测基准点左侧是否符合要求</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) --right; <span class="comment">//检测基准点右侧是否符合要求</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;               <span class="comment">// 移动指针以继续</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归版</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="keyword">if</span> (left)</span><br><span class="line">        quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ul>
<p>堆排序的平均时间复杂度为 Ο(nlogn)。</p>
<p><strong>算法步骤</strong>:</p>
<ul>
<li>创建一个堆 H[0……n-1]；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li>
<li>重复步骤 2，直到堆的尺寸为 1。</li>
</ul>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 建立父节点指针和子节点指针</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">// 若子节点指针在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">// 先比较两个子节点大小，选择最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父结点大于子节点表明调整完全，直接退出函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化，i从最后一个父节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先将第一个元素和已排好元素前一位做交换，再重新调整，直到排序完全</span></span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>], &amp;arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>
<p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<p><strong>算法步骤</strong>：</p>
<ul>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ul>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, arr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counting_sort</span><span class="params">(<span class="type">int</span> *ini_arr, <span class="type">int</span> *sorted_arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> *count_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                count_arr[ini_arr[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] += count_arr[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                sorted_arr[--count_arr[ini_arr[j - <span class="number">1</span>]]] = ini_arr[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">free</span>(count_arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> *arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="type">int</span> *sorted_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                arr[i] = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ini_array: &quot;</span>);</span><br><span class="line">        print_arr(arr, n);</span><br><span class="line">        counting_sort(arr, sorted_arr, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sorted_array: &quot;</span>);</span><br><span class="line">        print_arr(sorted_arr, n);</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        <span class="built_in">free</span>(sorted_arr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ul>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong><br>基数排序有三种方法，这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 20</span></span><br><span class="line"><span class="comment">//#define SHOWPASS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">radixsort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, b[MAX], m = a[<span class="number">0</span>], <span class="built_in">exp</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; m) &#123;</span><br><span class="line">      m = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m / <span class="built_in">exp</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> bucket[BASE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      bucket[(a[i] / <span class="built_in">exp</span>) % BASE]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">      bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      b[--bucket[(a[i] / <span class="built_in">exp</span>) % BASE]] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      a[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exp</span> *= BASE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOWPASS</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPASS   : &quot;</span>);</span><br><span class="line">    print(a, n);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> arr[MAX];</span><br><span class="line">  <span class="type">int</span> i, n;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter total elements (n &lt;= %d) : &quot;</span>, MAX);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  n = n &lt; MAX ? n : MAX;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter %d Elements : &quot;</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nARRAY  : &quot;</span>);</span><br><span class="line">  print(&amp;arr[<span class="number">0</span>], n);</span><br><span class="line"></span><br><span class="line">  radixsort(&amp;arr[<span class="number">0</span>], n);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nSORTED : &quot;</span>);</span><br><span class="line">  print(&amp;arr[<span class="number">0</span>], n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>欺骗攻击</title>
    <url>/%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<blockquote>
<p>欺骗攻击是网络攻击一种重要手段。常见的欺骗攻击方式有：DNS欺骗攻击、Email欺骗攻击、Web欺骗攻击和IP欺骗攻击等</p>
</blockquote>
<span id="more"></span>

<h2 id="DNS欺骗攻击"><a href="#DNS欺骗攻击" class="headerlink" title="DNS欺骗攻击"></a>DNS欺骗攻击</h2><h3 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h3><p>DNS(Domain Name System)<br>在传输层通常使用UDP协议，常用端口为53</p>
<h3 id="DNS欺骗原理"><a href="#DNS欺骗原理" class="headerlink" title="DNS欺骗原理"></a>DNS欺骗原理</h3><h2 id="Email欺骗攻击"><a href="#Email欺骗攻击" class="headerlink" title="Email欺骗攻击"></a>Email欺骗攻击</h2><h2 id="Web欺骗攻击"><a href="#Web欺骗攻击" class="headerlink" title="Web欺骗攻击"></a>Web欺骗攻击</h2><h3 id="Web欺骗原理"><a href="#Web欺骗原理" class="headerlink" title="Web欺骗原理"></a>Web欺骗原理</h3><p>攻击者通过伪造某个WWW站点的影像拷贝，</p>
<h2 id="IP欺骗攻击"><a href="#IP欺骗攻击" class="headerlink" title="IP欺骗攻击"></a>IP欺骗攻击</h2>]]></content>
  </entry>
  <entry>
    <title>网络木马</title>
    <url>/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/</url>
    <content><![CDATA[<blockquote>
<p>WHU_NCC计算机病毒慕课第九章网络木马知识整理，转载自他人，仅作学习</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>版权声明：本文为博主<a href="https://blog.csdn.net/daibaohui?type=blog">daibaohui</a>原创文章，遵循 CC 4.0 BY-SA 版权协议，此处为转载，因为和慕课视频讲的一毛一样，就直接用现成的了，仅作知识归档</p>
<p>本文链接：<a href="https://blog.csdn.net/daibaohui/article/details/113889229">https://blog.csdn.net/daibaohui/article/details/113889229</a></p>
</blockquote>
<h3 id="木马的特点"><a href="#木马的特点" class="headerlink" title="木马的特点"></a>木马的特点</h3><p>木马全称为特洛伊木马，来源于古希腊神话。木马是通过<strong>欺骗或诱骗</strong>的方式安装，并在用户的计算机中<strong>隐藏</strong>以实现控制用户计算机的目的，具有<strong>远程控制、信息窃取、破坏</strong>等功能。</p>
<p>木马具有如下特点：</p>
<ul>
<li><p>欺骗性：木马都有很强的欺骗性，执行通常都由被攻击者自己执行起来的</p>
</li>
<li><p>隐藏性</p>
</li>
<li><p>非授权性：执行恶意操作是没有经过用户授权的</p>
</li>
<li><p>交互性：主机之外的攻击者可以通过某种方式对主机进行交互</p>
</li>
</ul>
<h3 id="木马的分类"><a href="#木马的分类" class="headerlink" title="木马的分类"></a>木马的分类</h3><p>不同视角有不同的分类</p>
<h4 id="行为视角"><a href="#行为视角" class="headerlink" title="行为视角"></a>行为视角</h4><p>粒度细，如卡巴斯基SafeStream病毒库的分类标准。由下图所示，它是卡巴斯基整个对恶意代码分类体系，最上面的是蠕虫（Worm）和病毒（Virus），接着是后门（Backdoor）和Trojan，接着将Trojan按行为分成了很多类，最后是Rootkit和Exploit。从下往上是按照危害程度进行排序，最上面的危害程度最大、最下面的危害程度最小。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/1_%E5%8D%A1%E5%B7%B4%E6%96%AF%E5%9F%BA%E5%88%86%E7%B1%BB.png" class="" title="卡巴斯基病毒分类">

<p>下面这张图是卡巴斯基木马的具体分类，木马分为Backdoor(后门)、Trojan（木马）、Rootkit（提权）、Exploit（漏洞利用）。 按道理说，将Exploit放到木马范畴是不合适的，接着Trojan又分为Trojan-Downloader（下载）、Trojan-Dropper（释放）、Trojan-Spy（间谍软件）Trojan-DDoS（拒绝服务）、Trojan-Ransom（磁盘数据加密勒索用户）等。同时，它在命名的时候会根据其行为进行分类。对于卡巴斯基来说，Backdoor包括远程控制型程序，就是这篇文章的远控型木马。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/2_%E5%8D%A1%E5%B7%B4%E6%96%AF%E5%9F%BA%E6%9C%A8%E9%A9%AC.png" class="" title="卡巴斯基木马分类">


<h4 id="功能视角"><a href="#功能视角" class="headerlink" title="功能视角"></a>功能视角</h4><p>包括远程控制型、信息获取型、破坏型等。</p>
<h5 id="远程控制型木马"><a href="#远程控制型木马" class="headerlink" title="远程控制型木马"></a>远程控制型木马</h5><p>远程控制可以对目标计算机进行交互性访问（实时或非实时），可以下发相应的指令触发恶意软件的功能，也能获取目标的各种数据。其交互性是双向的（攻击者-被控制端）。<br>典型案例包括卡巴斯基分类标准下的木马之类Backdoor，还有一些实际案例，包括冰河、网络神TOU、广外女神、网络公牛、黑洞、上兴、彩虹桥、PCShare、灰鸽子等。下图展示了灰鸽子代码。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/3_%E7%81%B0%E9%B8%BD%E5%AD%90.png" class="" title="灰鸽子">

<h5 id="信息获取型木马"><a href="#信息获取型木马" class="headerlink" title="信息获取型木马"></a>信息获取型木马</h5><p>信息型获取木马的功能是信息获取，可以从键盘输入、内存、文件、数据库、浏览器Cookies等中获取有价值的信息。其交互性是单向交互，是被控制端发送数据给攻击者，比如发送至攻击者的第三方空间、文件服务器、指定邮箱等，或者直接开启FTP服务程序，攻击者直接访问从而下载数据。</p>
<p>下图展示了BPK软件界面，包括屏幕截屏、信息记录等功能，并发送数据给攻击者。典型案例包括卡巴斯基分类标准下的Trojan-Bank、Trojan-GameThief、Trojan-IM、Trojan-Spy、Trojan-PSW、Trojan-Mailfinder等。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/4_BPK.png" class="" title="BPK">

<h5 id="破坏性木马"><a href="#破坏性木马" class="headerlink" title="破坏性木马"></a>破坏性木马</h5><p>它的功能是对本地或远程主机系统进行数据破坏、资源消耗等。其交互性也是单向的，攻击者可以向被控制端发送指令，有的情况也没有任何交互。<br>典型案例包括卡巴斯基分类标准下的Trojan-DDoS、Trojan-Ransom、Trojan-ArcBomb、Trojan-Downloader、Trojan-Dropper等。</p>
<h3 id="木马的植入方式"><a href="#木马的植入方式" class="headerlink" title="木马的植入方式"></a>木马的植入方式</h3><p>木马的欺骗性很强，那么它究竟是通过什么方式去欺骗用户安装这个程序呢？常见方式如下：</p>
<h4 id="网页挂马植入"><a href="#网页挂马植入" class="headerlink" title="网页挂马植入"></a>网页挂马植入</h4><p>通过网页挂马实现比较典型，通常需要利用浏览器或相关漏洞，再结合实时新闻、热点话题制作相关网页，将漏洞和网页结合，最后生成恶意网页，当用户打开网页时，远程的木马程序会自动下载和安装。常见的漏洞比如：MS06014、MS10003。</p>
<h4 id="电子邮件植入（鱼叉攻击）"><a href="#电子邮件植入（鱼叉攻击）" class="headerlink" title="电子邮件植入（鱼叉攻击）"></a>电子邮件植入（鱼叉攻击）</h4><p>电子邮件植入最常见的是通过附件的形式，当用户打开附件时被注入木马；另一种是电子邮件与恶意网页相结合，由于电子邮件是支持HTML正文的，如果将相关漏洞植入到网页中，也是能够达到相关的效果。即使不打开附件，选中就会被植入（以HTML格式发送，如求职者）</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/5_%E9%B1%BC%E5%8F%89%E6%94%BB%E5%87%BB.png" class="" title="鱼叉攻击">

<h4 id="文档捆绑植入（鱼叉攻击偏多）"><a href="#文档捆绑植入（鱼叉攻击偏多）" class="headerlink" title="文档捆绑植入（鱼叉攻击偏多）"></a>文档捆绑植入（鱼叉攻击偏多）</h4><p>这也是一种有效的方式，通过office文档、pdf文档漏洞等将文档进行捆绑，当用户打开文档时会触发漏洞，从而释放木马或执行shellcode执行远程攻击。这种文档同时也常用于邮件附件的形式发送。</p>
<h4 id="伪装欺骗植入"><a href="#伪装欺骗植入" class="headerlink" title="伪装欺骗植入"></a>伪装欺骗植入</h4><p>比如可以对exe的文件后缀名进行修改，在原本一个“exe”文件前增加“doc”，然后输入很多空格让其exe不显示出来，再修改成文档类图标，从而进行伪装；另一种是更改后缀名（Unicode翻转字符），将“cod”进行翻转，再就是图标伪装等。</p>
<h4 id="捆绑植入"><a href="#捆绑植入" class="headerlink" title="捆绑植入"></a>捆绑植入</h4><p>EXE捆绑、文档嵌入、多媒体文件、电子书植入。（CVE-2018-20250）WinRAR捆绑文件的方法。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>比如特定U盘植入（故意丢弃、或者工作U盘、数据拷贝等）、社会工程等。</p>
<h3 id="木马的通信方式"><a href="#木马的通信方式" class="headerlink" title="木马的通信方式"></a>木马的通信方式</h3><p>木马的控制端和被控端要通信，首先要建立传输的通道，常见的传输通道构建需要通过IP地址、端口等信息、第三方网站地址实现。建立通信的方式包括两类：正向连接;   反向连接</p>
<h4 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h4><p>正向连接是指控制端主动去连接被控制端，需要被控制端开放相关端口来供控制端连接。首先，控制端会去连接被控端，然后发送相关的控制指令，被控端会将主机上的相关信息反馈给控制端，通常包括IP地址、MAC地址、计算机名称、内存大小等。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/6_%E6%AD%A3%E5%90%91%E8%BF%9E%E6%8E%A5.png" class="" title="正向连接">

<p>这种连接会存在一个问题，如果对方系统存在防火墙的话，通常会进行拦截。正向连接的优缺点如下：</p>
<p>优点:</p>
<ul>
<li>攻击者无需外部IP地址，只要能够上网，就能够去连接远程主机</li>
<li>木马样本不会泄露攻击者IP地址，木马不会主动去对外连接，不会泄露IP</li>
</ul>
<p>缺点:</p>
<ul>
<li>可能被防火墙阻挡</li>
<li>被攻击者必须具备外部IP地址</li>
<li>定位被攻击者相对困难，比如被攻击者IP是否变化？目标主机何时上线？当然有些木马，在目标主机主机能够上网时，会给指定邮箱发送IP地址信息，攻击者收到IP地址后会去主动连接主机。</li>
</ul>
<h4 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h4><p>第一种方式是右边的被控端（服务端）主动连接控制端主机，这种情况下防火墙一般会允许通过，尤其是目前很多木马程序采用80端口作为远程连接的端口，防火墙会非常信任。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/7_%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5.png" class="" title="反向连接">

<p>第一种方式的优缺点如下：</p>
<p>优点：</p>
<ul>
<li>通过防火墙相对容易</li>
<li>可以控制局域网内的目标</li>
<li>攻击目标随时上线，攻击者可以进行随时控制，因为攻击者控制服务器一直在线，只要被控端上线就会连接过来，甚至可以通过短信等方式告知。</li>
</ul>
<p>缺点：</p>
<ul>
<li>样本会暴露控制服务器信息（域名或IP）</li>
<li>攻击者通常应当具有外部IP</li>
</ul>
<p>关于反向连接，还有另外一种方式，被控端和控制端之间有个第三方的肉机，它们都和第三方通信，比如肉机、Web服务器。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/8_%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A52.png" class="" title="反向连接2">

<p>优点：</p>
<ul>
<li>可绕过防火墙，自动连接上线，不易被发现（代理）</li>
</ul>
<p>缺点：</p>
<ul>
<li>肉鸡的稳定性需要保障</li>
</ul>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>TCP协议：</p>
<ul>
<li>稳定、易被发现</li>
<li>HTTP协议伪装</li>
</ul>
<p>UDP协议：</p>
<ul>
<li>和TCP一样也有正向、反向两种方式</li>
<li>负载比TCP少，但是可靠性低</li>
</ul>
<p>ICMP＋TCP／UDP：</p>
<ul>
<li>该方式平时不开启端口，但会监听ICMP报文，以感知木马数据。当攻击者想对这台主机控制时，可以发送ICMP报文，发过来之后控制端监听到特定报文时，就知道到想要进行监听并开启相关端口。ICMP报文是由系统内核或进程直接处理而不是通过端口，其方式比较隐蔽，一般不会被防火墙过滤。</li>
</ul>
<p>下图展示了冰河写的后门程序，叫BITS（Background Intelligent Transfer Service），是一种难以觉察的后门，采用ICMP＋TCP／UDP方式实现。进程管理器首先看不到，另外平时没有端口，只是在系统中充当卧D的角色，并且提供正向连接和反向连接两种功能，适用于不同的操作系统（Windows2000&#x2F;XP&#x2F;2003），通过其提供的Shell，你能做很多事情。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/9_BITS.png" class="" title="BITS">



<h3 id="远控木马的常见功能及意图"><a href="#远控木马的常见功能及意图" class="headerlink" title="远控木马的常见功能及意图"></a>远控木马的常见功能及意图</h3><h4 id="木马结构"><a href="#木马结构" class="headerlink" title="木马结构"></a>木马结构</h4><p>首先看下木马的结构，一般由三部分组成，包括木马配置程序、控制端程序（客户端）和被控制端程序（服务端程序）。其中配置程序用于配置被控端的特征和功能，包括是否创建服务、是否隐藏等。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/10_%E6%9C%A8%E9%A9%AC%E7%BB%93%E6%9E%84.png" class="" title="木马结构">

<p>下图展示了PcShare的主控界面，其中“生成客户”点击后就是木马的配置过程。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/11_PCshare.png" class="" title="PCshare">

<p>下图展示了木马上线后的控制界面，包括目录浏览、屏幕控制、进程列表、窗口列表、服务管理、注册表编辑、键盘记录等。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/12_PCshare2.png" class="" title="PCshare">

<p>下面是灰鸽子的主界面。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/13_%E7%81%B0%E9%B8%BD%E5%AD%902.png" class="" title="灰鸽子">

<h4 id="木马功能"><a href="#木马功能" class="headerlink" title="木马功能"></a>木马功能</h4><p>木马的典型功能包括：</p>
<h5 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h5><p>文件管理主要目的是获取目标的文件系统信息，通常包括如下功能：</p>
<ul>
<li>浏览各磁盘文件</li>
<li>上传、下载文件（包括上传恶意文件）</li>
<li>执行文件</li>
<li>删除文件</li>
<li>修改文件信息（如文件属性、时间）</li>
</ul>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/14_%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.png" class="" title="文件管理">

<blockquote>
<p>可能涉及的部分关键函数: GetLogicalDriveString、 GetDiskFreeSpace(Ex)、GetVolumeInformation、GetDriveType、 FindFirstFile、 FindNextFile、 FindClose、DeleteFile、SHFileOperation 、SHEmptyRecycledBin、 MoveFile、 CreateFile( Ex) 、WriteFile 等</p>
</blockquote>
<h5 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h5><p>查看、结束、暂停目标系统进程。具体目的包括：</p>
<ul>
<li>查看目标系统的环境信息<ul>
<li>通过进程查看功能可以实现查看安装了哪些软件？目前对方正在做什么？</li>
</ul>
</li>
<li>停止或暂停目标系统的相关程序，从而形成干扰<ul>
<li>如反病毒程序</li>
</ul>
</li>
</ul>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/15_%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.png" class="" title="进程管理">

<blockquote>
<p>涉 及 的 关 键 函 数 包 括：CreateToolhelp32SnapShot、 Process32First、Process32Next、 EnumProcesses、 GetCurrentProcess、 OpenProcessToken、LookupPrivilegeValue、 AdjustTokenPrivilege、 OpenProcess、 GetModuleBaseName、EnumProcessModules、 GetModuleFileNameEx、 TerminateProcess 等。</p>
</blockquote>
<h5 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h5><p>主要功能是查看并管理目标系统的服务，包括：</p>
<ul>
<li>创建服务</li>
<li>启动&#x2F;停止服务</li>
<li>删除服务</li>
</ul>
<blockquote>
<p>可能涉及的关键函数: OpenSCManager、EnumServiceStatus、OpenService、 QueryServiceConfig、 StartService、StopService、 DeleteService 等。</p>
</blockquote>
<p>下图是PcShare提供的服务管理示例。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/16_%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86.png" class="" title="服务管理">

<h5 id="注册表管理"><a href="#注册表管理" class="headerlink" title="注册表管理"></a>注册表管理</h5><p>注册表管理可以浏览注册表的信息及键值，也能创建、删除一些键值。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/17_%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%AE%A1%E7%90%86.png" class="" title="注册表管理">

<blockquote>
<p>可能涉及的关键函数包括: RegQueryInfoKey、RegEnumKeyEx、 RegEnumValue、 RegCreateKeyEx、RegDeleteKey、 RegSetValueEx、 RegDeleteValue 等。</p>
</blockquote>
<h5 id="屏幕控制"><a href="#屏幕控制" class="headerlink" title="屏幕控制"></a>屏幕控制</h5><ul>
<li>利用 keybd_event 或者SendInput 模拟按键PrintScreen</li>
<li>利用 CreateDC 获取当前屏幕设备的句柄，然后获取屏幕图像</li>
</ul>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/18_%E5%B1%8F%E5%B9%95%E6%8E%A7%E5%88%B6.png" class="" title="屏幕控制">

<h5 id="键鼠操作"><a href="#键鼠操作" class="headerlink" title="键鼠操作"></a>键鼠操作</h5><p>下图是PcShare远程控制的键盘控制</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/19_%E9%94%AE%E9%BC%A0%E6%93%8D%E4%BD%9C.png" class="" title="键鼠操作">

<blockquote>
<p>主要涉及函数：<br>SetCursorPos、mouse_event、SendInput</p>
</blockquote>
<h5 id="屏幕截取"><a href="#屏幕截取" class="headerlink" title="屏幕截取"></a>屏幕截取</h5><p>对于有些木马来说，会认为屏幕控制功能流量消耗很大，不希望引起被控制着注意，有时候进行屏幕抓取即可。</p>
<ul>
<li>抓取屏幕（单张、多张连续）</li>
<li>了解目标主机的当前操作情况</li>
</ul>
<blockquote>
<p>常见函数包括：<br>CreateDC、CreateCompatibleBitmap、BitBlt</p>
</blockquote>
<h5 id="语音视频截获"><a href="#语音视频截获" class="headerlink" title="语音视频截获"></a>语音视频截获</h5><p>录音:</p>
<ul>
<li>窃取对方谈话信息</li>
<li>窃取对方对外语音通话（如QQ、SKYPE、MSN等），甚至即使是在断网的环境也可能会被录音，当连接网络后再传输对应的数据。</li>
</ul>
<p>摄像头:</p>
<ul>
<li>打开摄像头（了解对方现场环境）</li>
<li>摄像录制（敲诈）等。</li>
</ul>
<p>下图展示了语音视频截获的过程。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/20_%E8%AF%AD%E9%9F%B3%E8%A7%86%E9%A2%91%E8%8E%B7%E5%8F%96.png" class="" title="语音视频获取">

<h5 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h5><p>获取目标电脑中的键盘击键信息，包括：</p>
<ul>
<li>用户名、密码信息</li>
<li>QQ、邮箱、网银、网上证券、网络游戏、支付宝等</li>
<li>聊天信息</li>
<li>部分木马支持中文汉字记录</li>
</ul>
<hr>
<p>其他功能还有窗口管理，比如查看目标主机目前开启了哪些窗口，了解目标用户正在做什么；</p>
<p>再就是远程Shell，包括交互式或非交互式Shell（远程交互的Cmd.exe）、直接执行命令或第三方程序等。</p>
<p>部分木马功能如下图所示，其中很多功能所有木马都具有，比如文件管理、注册表管理、屏幕监控，也有一些功能是特有的。</p>
<img src="/%E7%BD%91%E7%BB%9C%E6%9C%A8%E9%A9%AC/21_%E6%9C%A8%E9%A9%AC%E5%8A%9F%E8%83%BD.png" class="" title="木马功能">


<h3 id="木马的性能"><a href="#木马的性能" class="headerlink" title="木马的性能"></a>木马的性能</h3><p>编写木马的关键：</p>
<ul>
<li>功能适当［精简灵活］</li>
<li>适用性强［功能、权限］</li>
<li>高效、稳定、隐蔽［传输］</li>
<li>可穿透性</li>
<li>自更新、自销毁</li>
<li>反调试、反分析、防追踪、反制对抗</li>
<li>持续免杀性能等<ul>
<li>特征值、通用主机行为、异常的通信流量</li>
</ul>
</li>
</ul>
<h3 id="木马的检测思路"><a href="#木马的检测思路" class="headerlink" title="木马的检测思路"></a>木马的检测思路</h3><p>既然远控木马也是恶意软件，那么怎么检测木马呢？下面简单提供了一些思路：</p>
<ul>
<li>静态文件特征（木马程序是独立的文件，就存在静态文件特征）</li>
<li>网络流量特征（交互性木马检测流量）</li>
<li>系统行为特征（木马执行时创建线程、进程、驱动、网络等行为）</li>
<li>功能行为特征（录音、截屏、键盘、shell行为检测）</li>
<li>攻击意图（自动化检测功能是正常或恶意，当然难度也大）</li>
</ul>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>木马</tag>
      </tags>
  </entry>
  <entry>
    <title>网络蠕虫</title>
    <url>/%E7%BD%91%E7%BB%9C%E8%A0%95%E8%99%AB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>蠕虫</tag>
      </tags>
  </entry>
  <entry>
    <title>计网实验</title>
    <url>/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p>此贴为WHU_网安院计网实验备忘（每次都忘记基本指令和参数之类的(&#x2F;(ㄒoㄒ)&#x2F;~~)），写一些基本命令，以及注意事项之类的，不涉及详细实验步骤（我也想写，但是实验报告太多惹🆘）</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>实验平台：<a href="http://10.201.133.200:8080/szy">http://10.201.133.200:8080/szy</a></p>
<p>账号密码：********（看不到吧，老师会给你自己的）</p>
</blockquote>
<hr>
<h2 id="实验内容（补充中）"><a href="#实验内容（补充中）" class="headerlink" title="实验内容（补充中）"></a>实验内容（补充中）</h2><ol>
<li>静态路由实验</li>
<li>动态路由实验<ol>
<li>RIP路由协议（包含dhcp协议、md5加密）</li>
<li>OSFP路由协议</li>
</ol>
</li>
<li>VLAN配置实验</li>
</ol>
<hr>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p><strong>注意</strong>：</p>
<ul>
<li>需要连线！需要连线！路由配置好了不连线是行不通滴🤡</li>
<li>关以太网！关以太网！机架中当PC用的电脑要关掉以太网，不然你会ping不通的</li>
</ul>
<h3 id="1-静态路由实验"><a href="#1-静态路由实验" class="headerlink" title="1.静态路由实验"></a>1.静态路由实验</h3><p>先规划好各个接口的IP地址，给设备连线。端口别接错了，只有中间几个口能用（i dont’t know why），防止迷糊，放个图：</p>
<img src="/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/1.%E8%B7%AF%E7%94%B1%E5%99%A8.png" class="" title="图片">

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令有缺省，为了方便（好吧，是因为记不住）</span></span><br><span class="line"><span class="comment">// 先进控制台</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置设备要进config模式</span></span><br><span class="line">&gt;&gt; enable</span><br><span class="line">&gt;&gt; config</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改个名</span></span><br><span class="line">&gt;&gt; hostname 名字    <span class="comment">// RA、RB、RC之类的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看配置信息</span></span><br><span class="line">&gt;&gt; show ip route    <span class="comment">// 查看路由表，我个人用的最多</span></span><br><span class="line">&gt;&gt; show running     <span class="comment">// 查看当前配置</span></span><br><span class="line">&gt;&gt; show interface   <span class="comment">// 查看接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置路由器各个端口的IP</span></span><br><span class="line"><span class="comment">// 组内协商好，不要用本地网段全0的，不要互相冲突</span></span><br><span class="line"><span class="comment">// 先进入端口</span></span><br><span class="line"><span class="comment">// 命令全称：interface gigabitEthernet 0/1（这么长，记个毛线）</span></span><br><span class="line">&gt;&gt; <span class="type">int</span> g0/<span class="number">0</span>     <span class="comment">// 表示0端口，g0/1表示1端口</span></span><br><span class="line">&gt;&gt; ip add IP地址 子网掩码</span><br><span class="line">&gt;&gt; no shutdown  <span class="comment">// 打开端口，我也不知道不写有没有影响</span></span><br><span class="line">&gt;&gt; <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置静态路由</span></span><br><span class="line"><span class="comment">// 目标网络不要填具体的主机Ip，哪怕该网络只有一台主机</span></span><br><span class="line"><span class="comment">// 下一跳地址为相连的下一个路由器的端口IP，不是本路由器的转发端口</span></span><br><span class="line">&gt;&gt; ip route 目标网络 子网掩码 下一跳地址</span><br><span class="line">&gt;&gt; ip route <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>     <span class="comment">// 默认地址设置，没用过</span></span><br><span class="line">&gt;&gt; no ip route ……   <span class="comment">// 配错路由的时候反悔用的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>配好各个路由器之后，记得检查有无漏的错的</p>
<p><strong>！！！</strong> PC的IP要自己手配哦（应该都会吧？先不细说了，有空再）</p>
<p>都搞好后就可以开始在控制台和各个PC的CMD中尽情地ping了</p>
<blockquote>
<p>推荐另一个命令<code>tracert 目标IP</code>可以显示通信的路径，方便调试</p>
</blockquote>
<p><strong>补充</strong>：三层交换机配置方法<br>一直是我队友配的这个，所以非常不熟呃呃呃，仅供参考!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不做配置，可以直接当二层交换机使用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="动态路由实验"><a href="#动态路由实验" class="headerlink" title="动态路由实验"></a>动态路由实验</h3><blockquote>
<p>记得进config再配路由器哦🌹</p>
</blockquote>
<h4 id="RIP路由协议"><a href="#RIP路由协议" class="headerlink" title="RIP路由协议"></a>RIP路由协议</h4><p>先连线</p>
<p>再配各个路由器的IP（跟上边一样）</p>
<p>然后配DHCP，给各个主机自动分配IP</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; ip dhcp pool student  <span class="comment">// student应该可以随便改</span></span><br><span class="line">&gt; network <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> <span class="comment">// 只给相连的子网配</span></span><br><span class="line">&gt; <span class="keyword">default</span>-router <span class="number">192.168</span><span class="number">.1</span><span class="number">.254</span>   <span class="comment">// 默认网关</span></span><br><span class="line">&gt; service dhcp <span class="comment">// 开启dhcp服务</span></span><br></pre></td></tr></table></figure>

<p>配完记得在PC上查看下有没有成功</p>
<p>接着配RIP，让其动态学习路由</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; route rip <span class="comment">// 开启rip协议</span></span><br><span class="line">&gt; version <span class="number">2</span> <span class="comment">// 声明版本，1和2差别挺大好像，学过的忘完了已经（去世）</span></span><br><span class="line">&gt; no <span class="keyword">auto</span>-summary <span class="comment">// 关闭自动汇总，所配即所得</span></span><br><span class="line">&gt; network <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>   <span class="comment">// 申明本设备的直连网段</span></span><br><span class="line">&gt; network <span class="number">192.169</span><span class="number">.1</span><span class="number">.0</span>   <span class="comment">// 直连的有几个写几个，不用写子网掩码</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>RIP验证，用md5来做，可是我们没弄这个，就不谈了，私密吗喽🙇</p>
<p>接下来查看各个路由器的路由表，应该多了几个’r’开头的路由，即为路由器自己学习到的路由，然后就直接开ping!!!</p>
<h4 id="OSFP路由协议"><a href="#OSFP路由协议" class="headerlink" title="OSFP路由协议"></a>OSFP路由协议</h4><p>照例，先连线，配主机IP（可以用DHCP配，不过主机少的话，手配更省事点），路由器的IP（什么时候这个也能自动化）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我也没太搞懂这个</span></span><br><span class="line">&gt; osfp <span class="number">1</span>    <span class="comment">// 应该是版本？</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">个人理解：area是提前规划好的，有单区域、多区域（配起来好像没啥区别），所有和路由器端口直连的网段的IP都写上，子网掩码格式变了（没试过别的行不行）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&gt; network <span class="number">192.168</span><span class="number">.2</span><span class="number">.0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.255</span> area <span class="number">2</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配好之后，路由器之间会开始泛洪，互相交换链路信息，可以查看路由表，其中’o’开头的即为学习到的路由，带有时间信息，可以查看彼此之间学习的先后顺序（没啥用），至此，应该就可以测试连通性了</p>
<h3 id="VLAN配置实验"><a href="#VLAN配置实验" class="headerlink" title="VLAN配置实验"></a>VLAN配置实验</h3><p>VLAN网络为在交换机中配置，不涉及主机，主机只需配置相关网段的IP和默认网关（需要的话）</p>
<h4 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h4><img src="/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/2-vlan%E5%AE%9E%E9%AA%8C1.png" class="" title="vlan实验1">
<p>实验1实现跨交换机的同一vlan内的通信，不同vlan无法通信</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先进config</span></span><br><span class="line">&gt; vlan <span class="number">10</span> <span class="comment">// 声明一个虚拟局域网vlan 10</span></span><br><span class="line">&gt; <span class="type">int</span> g0/<span class="number">1</span> <span class="comment">// 进入该vlan下的某个端口</span></span><br><span class="line">&gt; switchport access vlan <span class="number">10</span> <span class="comment">// 将端口设为access，并划入该vlan中</span></span><br><span class="line"><span class="comment">// 如果该vlan有多个端口，重复上面两步</span></span><br><span class="line">&gt; <span class="built_in">exit</span></span><br><span class="line"><span class="comment">// 该交换机涉及几个vlan，就重复几次</span></span><br><span class="line"><span class="comment">//此外，有些端口需要允许不同vlan通过，此时要设置为trunk模式</span></span><br><span class="line">&gt; <span class="type">int</span> g3/<span class="number">0</span> <span class="comment">// 进入相关端口</span></span><br><span class="line">&gt; switchport mode trunk <span class="comment">// 设置为trunk模式</span></span><br><span class="line">&gt; show vlan <span class="comment">// 查看该交换机的vlan配置情况</span></span><br></pre></td></tr></table></figure>

<img src="/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/4-trunk.png" class="" title="trunk">

<p>以下是一个配置好的交换机2：</p>
<img src="/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/5-%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" class="" title="交换机">
<p>三个交换机配完，配置主机IP(同一子网，不需要网关)，就可以进行验证了</p>
<h4 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h4><p>此实验平台中没有，为PPT中要求，且lh老师亲自验收，所有人都拷打，建议没做的也要会做，懂点原理</p>
<img src="/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/3-vlan%E5%AE%9E%E9%AA%8C2.png" class="" title="vlan实验2">
<p>在上一实验中，不同的vlan之间由于逻辑上的隔离，无法进行通信，此实验中在三层网络设备上实现不同vlan之间的通信</p>
<p>原理：在三层交换机设置虚拟VLAN接口，实现VLAN之间的数据转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在三层交换机上建立不同的vlan，并为其分配不同网段的IP地址,当作对应vlan的网关</span></span><br><span class="line">&gt; vlan <span class="number">2</span></span><br><span class="line">&gt; ip add <span class="number">192.168</span><span class="number">.1</span><span class="number">.254</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">&gt; ip routing <span class="comment">// 貌似没用</span></span><br><span class="line">&gt; <span class="built_in">exit</span></span><br><span class="line"><span class="comment">// 有几个vlan就重复几次</span></span><br><span class="line"><span class="comment">// 让实际的端口封装vlan，并设置为trunk模式</span></span><br><span class="line">&gt; <span class="type">int</span> g0/<span class="number">1</span>  <span class="comment">// 实际的物理端口</span></span><br><span class="line">&gt; switchport trunk encapsulation dot1q <span class="comment">// 封装协议的参数无法识别，不用此命令也无影响</span></span><br><span class="line">&gt; switchport mode trunk</span><br><span class="line">&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>所有交换机配好后，分配主机的IP和网关（记得看清是哪个vlan下的，别搞混了），进行验证测试</p>
<h4 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h4><p>此实验为平台上的实验，考察另一种通过三层交换机实现不同VLAN通信的方法、单臂路由以及RIP协议配置，较为综合，容易出错</p>
<p>实验详情：<img src="/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/6-vlan%E5%AE%9E%E9%AA%8C3.png" class="" title="vlan实验3"><br>各个设备的IP配置如下：<img src="/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/7-ip%E9%85%8D%E7%BD%AE.png" class="" title="ip配置"></p>
<p>只有6台主机，所以上面服务器就不管了（也没用到）</p>
<p>总的来说，右下为三层交换机实现不同vlan通信，左下为单臂路由实现不同vlan通信，上半部分为RIP路由实现</p>
<blockquote>
<p>记得连线，路由器用中间四个接口，别连错了（来自别的组的血泪教训）</p>
</blockquote>
<p>先看右下，与实验二相比，在此，我们摒弃交换机的二层交换功能，将其看作一个路由器，，左右两个端口分别作为两个不同vlan的网关，对不同的vlan的数据进行转发，并在下面的二层交换机之间配置trunk模式，使数据可以流通（详细的vlan原理目前还是一知半解，后面再开专题单独讲吧）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先是两个二层交换机</span></span><br><span class="line">&gt; vlan <span class="number">10</span>   <span class="comment">// 声明一个vlan </span></span><br><span class="line">&gt; <span class="type">int</span> g0/<span class="number">1</span>  <span class="comment">// 进入某端口</span></span><br><span class="line">&gt; switchport access vlan <span class="number">10</span>   <span class="comment">// 配置vlan</span></span><br><span class="line">&gt; <span class="built_in">exit</span></span><br><span class="line"><span class="comment">// 与实验一几乎一模一样，不赘述</span></span><br><span class="line"><span class="comment">// 三层交换机</span></span><br><span class="line">&gt; no switchport   <span class="comment">// 关掉交换功能</span></span><br><span class="line">&gt; <span class="type">int</span> g0/<span class="number">1</span>  <span class="comment">// 进入某个端口</span></span><br><span class="line">&gt; ip add <span class="number">202.114</span><span class="number">.68</span><span class="number">.1</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>    <span class="comment">// 配置默认网关</span></span><br><span class="line"><span class="comment">// 重复，配置好各个端口的IP</span></span><br><span class="line">&gt; ip routing   <span class="comment">// 开启路由功能</span></span><br></pre></td></tr></table></figure>
<p>至此，此小部分的实验配置完成（记得配主机IP和网关），然后可以在pc3、4、5、6之间互ping，通了后进行下一步</p>
<p>再看左下角的单臂路由，原理就是路由器的子接口支持虚拟局域网</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交换机4正常配置，上面1号端口设置为trunk模式</span></span><br><span class="line"><span class="comment">// 路由器</span></span><br><span class="line">&gt; <span class="type">int</span> g0/<span class="number">2.1</span>   <span class="comment">// 设置子接口</span></span><br><span class="line">&gt; description vlan <span class="number">10</span>   <span class="comment">// 支持vlan10</span></span><br><span class="line">&gt; encapsulation dot1Q <span class="number">2</span> <span class="comment">// 用802.1Q协议封装vlan10</span></span><br><span class="line">&gt; ip address <span class="number">192.168</span><span class="number">.1</span><span class="number">.254</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  <span class="comment">// 设置IP地址</span></span><br><span class="line"><span class="comment">//几个子接口重复几次</span></span><br></pre></td></tr></table></figure>

<p>左下部分配置完后，配置主机IP和网关，测试两台主机的连通性</p>
<p>最后是RIP动态路由部分，与之前实验相同，不做赘述，需要注意的是此处交换机1是当作一个路由器使用，也需进行配置</p>
<p>所有的都配完后查看各个路由设备的路由表是否学习到相关路由，测试左右部分的连通性</p>
<h4 id="常见错误总结"><a href="#常见错误总结" class="headerlink" title="常见错误总结"></a>常见错误总结</h4><p>写了五次实验了，自己组或者朋友的组总有几次莫名出错，整理一个检错流程，或许有用</p>
<ul>
<li>检查连线，最高端的黑客往往采用最朴素的攻击方式，看下线有没有被别的组拔了，或者端口接对了没<ul>
<li>注意路由器只有中间四个端口能用，朋友的组接到前面然后vlan死活配不上去</li>
</ul>
</li>
<li>检查主机，很多时候ping不同可能是因为主机IP配错了，或者没配网关，又或者以太网没禁用，还有可能你用错主机了（doge）</li>
<li>查路由表，是不是配对了，动态路由学到没<ul>
<li>可以用<code>show running</code>命令，可以看到各个端口都配了啥，debug很好用</li>
</ul>
</li>
<li><code>tracert</code>命令，追查具体在哪儿出的错，然后再深入分析</li>
<li>互换设备检查下，有时候自己看不出来的问题，队友一眼就找到了，或者请教助教大人（我们助教人很好，曾将第一个实验帮我们de了一个小时的bug，成功成为最后一个下班的）</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>语音伪造及检测技术</title>
    <url>/%E8%AF%AD%E9%9F%B3%E4%BC%AA%E9%80%A0%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<blockquote>
<p>内容安全第九章课程笔记</p>
</blockquote>
<span id="more"></span>

<h2 id="语音伪造技术"><a href="#语音伪造技术" class="headerlink" title="语音伪造技术"></a>语音伪造技术</h2><p>语音伪造的主要手段：</p>
<ul>
<li>语音模仿：人类模拟，非自动化手段</li>
<li>语音篡改：编辑修改已有语音，增，删，改</li>
<li>语音合成：给定文本，实现文本到声音的映射</li>
<li>语音转换：不改变语音内容，实现声音到声音的映射</li>
<li>重放语音：语音经设备录制后进行编辑和回放</li>
<li>对抗攻击：对语音添加微量扰动，在不影响人耳感知的情况下，实现对深度ASV系统的欺骗攻击</li>
</ul>
<h3 id="语音合成"><a href="#语音合成" class="headerlink" title="语音合成"></a>语音合成</h3><img src="/%E8%AF%AD%E9%9F%B3%E4%BC%AA%E9%80%A0%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF/1-%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90.png" class="" title="语音合成">

<ul>
<li>文本分析：将输入文本通过规范化、分词、词性标注等步骤生成对应的音素序列、时长预测等信息</li>
<li>波形生成：根据文本分析生成的语言规范合成目标说话人的语音波形</li>
</ul>
<h4 id="传统语音合成技术"><a href="#传统语音合成技术" class="headerlink" title="传统语音合成技术"></a>传统语音合成技术</h4><img src="/%E8%AF%AD%E9%9F%B3%E4%BC%AA%E9%80%A0%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF/2-%E5%90%88%E6%88%90%E6%B5%81%E7%A8%8B.png" class="" title="语音合成流程">

<ul>
<li>语言知识：<ul>
<li>文本规范化</li>
<li>文本结构化</li>
<li>上下文特征</li>
</ul>
</li>
<li>声学优化<ul>
<li>连贯度准则</li>
<li>韵律表达</li>
</ul>
</li>
<li>波形生成<ul>
<li>后处理优化</li>
</ul>
</li>
</ul>
<p>首先，将文本进行分句处理</p>
<img src="/%E8%AF%AD%E9%9F%B3%E4%BC%AA%E9%80%A0%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF/3-%E5%88%86%E5%8F%A5.png" class="" title="分句模块">

<p>然后将特殊字符集进行处理，例如确定各种数据的读法</p>
<img src="/%E8%AF%AD%E9%9F%B3%E4%BC%AA%E9%80%A0%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF/4-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%A4%84%E7%90%86.png" class="" title="字符集处理">

<p>然后进行中文分词</p>
<img src="/%E8%AF%AD%E9%9F%B3%E4%BC%AA%E9%80%A0%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF/5-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D.png" class="" title="中文分词">

<h5 id="声学优化"><a href="#声学优化" class="headerlink" title="声学优化"></a>声学优化</h5><p>根据前端提供的文本特征，根据语音声学的准则优化，为波形生成提供输入（根据波形生成方法的不同使用不同的声学准则）</p>
<ul>
<li>每个音素发音多长</li>
<li>如何根据协同发音调整</li>
</ul>
<img src="/%E8%AF%AD%E9%9F%B3%E4%BC%AA%E9%80%A0%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF/6-%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99.png" class="" title="基于规则">
<p>需要大量的人工干预，实现自由文本的合成代价很高</p>
<h5 id="波形拼接法"><a href="#波形拼接法" class="headerlink" title="波形拼接法"></a>波形拼接法</h5><p>将语音数据中的语音单元按照一定的规则拼接，合成与目标说话人高度相似且自然的声音</p>
<ul>
<li>优点：使用真实的语音片段，可以最大限度保留语音本质</li>
<li>缺点：需要大量说话人语料；对于不同领域的文本合成稳定性不强，容易被人或机器识别</li>
<li>代表工作：基于基音同步叠加的PSOLA技术等</li>
</ul>
<h5 id="参数生成法"><a href="#参数生成法" class="headerlink" title="参数生成法"></a>参数生成法</h5><p>通过声学模型预测声学参数，然后将声学参数通过声码器合成出目标说话人语音</p>
<ul>
<li>优点：可以输出稳定流畅的语音</li>
<li>缺点：受限于参数合成器的缺陷以及统计建模的损失，合成的语音通常不够自然</li>
<li>代表工作：基于HMM的统计参数合成方法等</li>
</ul>
<h4 id="深度学习语音合成"><a href="#深度学习语音合成" class="headerlink" title="深度学习语音合成"></a>深度学习语音合成</h4>]]></content>
      <categories>
        <category>内容安全</category>
      </categories>
      <tags>
        <tag>语音伪造</tag>
        <tag>内容安全</tag>
      </tags>
  </entry>
</search>
